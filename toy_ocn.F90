! Copyright (c) 2024 The YAC Authors
!
! SPDX-License-Identifier: BSD-3-Clause

MODULE toy_ocn

  USE mpi
  USE yac
  USE netcdf
  USE yac_utils, ONLY : yac_test_gulfstream_c
  USE toy_common, ONLY : read_icon_grid, nsteps, define_fields, &
                         send_field, receive_field, max_char_length

  IMPLICIT NONE

  PRIVATE

  INTEGER :: t, ierror

  ! Basic string paramters
  CHARACTER(LEN=max_char_length), PARAMETER :: yaml_filename = "input/coupling.yaml"
  CHARACTER(LEN=max_char_length), PARAMETER :: comp_name = "ocn_comp"
  CHARACTER(LEN=max_char_length), PARAMETER :: grid_name = "ocn_grid"
  character(len = 5000) :: attr_grid_total
  
  ! IDs and communicator generated by YAC
  INTEGER :: comp_id, comp_comm ! = MPI_COMM_WORLD
  INTEGER :: comp_rank
  INTEGER :: grid_id
  INTEGER :: cell_point_id
  INTEGER :: field_taux_id, field_tauy_id
  INTEGER :: field_sfwflx_id
  INTEGER :: field_sftemp_id
  INTEGER :: field_thflx_id
  INTEGER :: field_iceatm_id, field_iceoce_id
  INTEGER :: field_sst_id
  INTEGER :: field_oceanu_id, field_oceanv_id
  integer(kind = 4) :: i
  
  ! Basic decomposed grid information
  INTEGER(kind = 4)             :: num_vertices_lon, num_vertices_lat, num_vertices
  INTEGER(kind = 4)             :: num_cells, num_vertices_per_cell

  DOUBLE PRECISION, ALLOCATABLE :: x_vertices(:), y_vertices(:)
  DOUBLE PRECISION, ALLOCATABLE :: x_cells(:), y_cells(:)

  integer, allocatable     :: global_cell_ids(:)
  INTEGER, ALLOCATABLE     :: cell_to_vertex(:,:)

  ! Buffer for field data
  DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE :: &
       taux, tauy, sfwflx, sftemp, thflx, iceatm, sst, oceanu, oceanv, iceoce

  PUBLIC :: main_ocn

CONTAINS

  SUBROUTINE main_ocn(comm)

    CHARACTER(LEN=max_char_length), PARAMETER :: grid_filename = "grids/GEIA_MPIC1.0_X_bioland_NH3_2000-2000.nc"
    character(len = 1000) :: name
    character(len = 5000) :: grid_metadata, field_metadata, comp_metadata
    ! Define communicator
    integer, intent(in) :: comm
    ! netCDF file identifier
    integer :: ncid
    ! Number of dimensions, variables, attributes and time steps in netCDF file
    integer :: ndim, nvar, natt, k_un
    ! Number of vertices (longitude, lattidtude, total)
    integer :: num_vertices_lon, num_vertices_lat, num_vertices
    ! Number of attributes, datatype of variable, number of dimensions, lenght of dimension
    integer :: natts, xtype, ndims, len
    integer :: k, status
    ! Definition of the cyclicity of the mesh (regular mesh)
    integer, dimension(2) :: cyclic = (/1, 0 /)
    integer, allocatable, dimension(:) :: dimids

    ! Correction value for corner centered grid
    real(kind = 8) :: correction_value_lat = 0.0, correction_value_lon = 0.0

    ! Definition of 1, 2, 3 and 4d fields for FLOAT and DOUBLE
    real(kind = 8), allocatable, dimension(:) :: field_double_1d
    real(kind = 8), allocatable, dimension(:, :) :: field_double_2d 
    real(kind = 8), allocatable, dimension(:, :, :) :: field_double_3d 
    real(kind = 8), allocatable, dimension(:, :, :, :) :: field_double_4d 
    real(kind = 8), allocatable, dimension(:) :: field_float_1d
    real(kind = 8), allocatable, dimension(:, :) :: field_float_2d 
    real(kind = 8), allocatable, dimension(:, :, :) :: field_float_3d 
    real(kind = 8), allocatable, dimension(:, :, :, :) :: field_float_4d 

    INTEGER :: point_id
    integer :: collection_size = 1
    integer :: def_field = -1
    INTEGER, PARAMETER :: num_point_ids = 1
    INTEGER :: point_ids(num_point_ids)
    CHARACTER(LEN=max_char_length), PARAMETER :: timestep = "1"
    INTEGER, PARAMETER :: timestep_unit = YAC_TIME_UNIT_SECOND

    
    type dimension_attr
       integer :: number_of_dim
       integer :: len_of_dim
       character(len = 1000) :: name_of_dim
    end type dimension_attr
    type(dimension_attr), allocatable, dimension(:) :: list_dimension_attr

    comp_comm = comm

    ! Read coupling configuration file
    CALL yac_fread_config_yaml(yaml_filename)

    ! Define local component and add metadata
    CALL yac_fdef_comp(comp_name, comp_id)
 
    write( comp_metadata, '(A)')  "Component MESSy IMPORT Server" 
    call yac_fdef_component_metadata(comp_name, comp_metadata)
    
    ! Retrieve communicator for MESSy server component
    ! CALL yac_fget_comp_comm(comp_id, comp_comm)

    ! Get component rank
    CALL MPI_Comm_rank(comp_comm, comp_rank, ierror)

    ! Read the grid and distribute it among all OCN processes
    !CALL read_icon_grid( &
    !     grid_filename, comp_comm, cell_to_vertex, x_vertices, &
    !     y_vertices, x_cells, y_cells, cell_sea_land_mask, &
    !     global_cell_id)
    !    num_vertices = SIZE(x_vertices)
    !    num_cells = SIZE(x_cells)
    !    num_vertices_per_cell = SIZE(cell_to_vertex, 1)

    !
    ! From here read netCDF file
    !
    
    ! Open netCDF file
    write(*, *)
    write(*, *) "----- OCNN: Open ocean netCDF file -----"
    status = nf90_open(trim(grid_filename), nf90_nowrite, ncid)
    if(status /= nf90_noerr) then
       write(*, *) 'OCN: Could not open ', grid_filename
       write(*, *) status
       write(*, *) '***** OCN: Unable to find netCDF file *****'
       stop
    endif

    ! Inquiry of the nuber of variables, etc
    write(*, *)
    write(*, *) "----- OCN: Inquire number of dimensions, variables, etc -----"
    status = nf90_inquire(ncid, ndim, nvar, natt, k_un)
    if (status /= nf90_noerr) then
       write(*, *) 'OCN: nf90_inquire error'
       write(*, *) status
       write(*, *) '***** OCN: Unable to read number of variables, etc *****'
       stop
    endif

    ! Create list of type dimension_attr and dimids
    allocate(list_dimension_attr(ndim))
    allocate(dimids(ndim))

    ! Read the values of every dimension to element k of list_dimension_attr
    write(*, *)
    write(*, *) "----- OCN: Output of dimensions id, length and name -----"
    do k = 1, ndim
       status = nf90_inquire_dimension(ncid, k, name, len)
       if (status /= nf90_noerr) then
          write(*, *) "OCN: n90_inquire_dimension error" 
          write(*, *) status
          stop
       endif

       list_dimension_attr(k)%number_of_dim = k
       list_dimension_attr(k)%len_of_dim = len
       write(list_dimension_attr(k)%name_of_dim, '(A)') name
    
       ! read number vertices in longitude directions (vertex is midpoint of cell)
       if(index(trim(name), 'lon') /= 0) then
          num_vertices_lon = len
       end if

       ! read number vertices in lattitude directions (vertex is midpoint of cell)
       if(index(trim(name), 'lat') /= 0) then
          num_vertices_lat = len
       end if
    enddo ! do k = 1, ndim


    
    ! Read variables first part, to get the lon and lat out
    write(attr_grid_total, '(A)') ''
    do k = 1, nvar
       name = ''
       status = nf90_inquire_variable(ncid, k, name, xtype, ndims, dimids, natts)
       if (status /= nf90_noerr) then
          write(*, *) "OCN: n90_inquire_variable error"
          write(*, *) status
          stop
       endif

       write(*, *) "OCN: 1st Results of nf90_inquire_variable call: ", ncid, ", ", k, ", ", trim(name), ", ", xtype, ", "
       write(*, *) "OCN: 1st Results of nf90_inquire_variable call: ", ndims, ", ", dimids, ", ", natts

       if(natts > 0) then
          call parse_attr_list(ncid, natts, k, attr_grid_total)
          write(*, *)
          write(*, *) "OCN: attr_grid_total: ", trim(attr_grid_total)
          write(*, *)
       endif
       
       if(index(trim(attr_grid_total), 'degrees_east') /= 0) then
          write(*, *) "1st lon units degrees_east"
          write(*, *) "1st lon ", trim(attr_grid_total)
       endif

       if(index(trim(attr_grid_total), 'degrees_north') /= 0) then
          write(*, *) "1st lat units degrees north"
          write(*, *) "1st lat ", trim(attr_grid_total)
       endif

       
       if(xtype == NF90_DOUBLE) THEN
          if(ndims == 1) then
             write(*, *) "OCN: Type DOUBLE 1d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             allocate(field_double_1d(list_dimension_attr(dimids(1))%len_of_dim))
             write(*, *) "After allocation of field_double_1d"

             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_double_1d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             ! Output of field
             write(*, *) "OCN: field_double_1d"
             write(*, *) field_double_1d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             write(*, *) "OCN Before yac_fdef_field"
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field"
          endif
       end if
    end do
    ! END Read variables first part, to get the lon and lat out
    
    allocate(x_cells(num_vertices_lon))
    allocate(y_cells(num_vertices_lat))

    ! Number of cells is product of vertices in lat and lon direction because
    ! usually the coordinates are centered in an element
    num_cells = num_vertices_lon * num_vertices_lat

    ! Now correction to number of vertices if vertex is on a real node and not in cell center
    num_vertices_lon = num_vertices_lon + 1
    num_vertices_lat = num_vertices_lat + 1 
    num_vertices = num_vertices_lon * num_vertices_lat

    ! Allocate vector for x and y vertices
    allocate(x_vertices(num_vertices_lon))
    allocate(y_vertices(num_vertices_lat))

    ! Allocate and fill the arry cell_to_vertex with the vertices of the elements
    allocate(cell_to_vertex(num_cells, 4))
    allocate(global_cell_ids(num_cells))

    ! Define local part of the grid
    write(*, *)
    write(*, *) "OCN: Before YAC_FDEF_GRID"
    !    CALL yac_fdef_grid ( &
    !         grid_name, num_vertices, num_cells, num_vertices_per_cell, &
    !         x_vertices, y_vertices, cell_to_vertex, grid_id )

    ! Interface for yac_fdef_grid_reg2d_dble 
    cyclic = (/ 1,0/)
    CALL yac_fdef_grid( &
         grid_name, (/ num_vertices_lon, num_vertices_lat /), cyclic, &
         x_vertices, y_vertices, grid_id )

    write(*, *) "OCN: After YAC_FDEF_GRID"
    write(*, *)

    ! Define metadata for grid
    write( grid_metadata,'(A)') "Mesh regular"
    CALL yac_fdef_grid_metadata(grid_name, grid_metadata)

    ! Set global cell ids
    CALL yac_fset_global_index(global_cell_ids, YAC_LOCATION_CELL, grid_id)

    ! Define location of the actual data (on cell centers)
    write(*, *)
    write(*, *) "OCN: Before YAC_FDEF_POINTS"

    CALL yac_fdef_points ( &
         grid_id, (/ num_vertices_lon, num_vertices_lat /), YAC_LOCATION_CORNER, &
         x_vertices, y_vertices, cell_point_id )
    write(*,*) "cell_point_id: ", cell_point_id

    point_id = cell_point_id
    point_ids(1) = point_id

    !    CALL yac_fdef_points ( &
    !        grid_id, (/ num_vertices_lon-1, num_vertices_lat-1 /), YAC_LOCATION_CELL, &
    !        x_cells, y_cells, cell_point_id )

    write(*, *)
    write(*, *) "OCN: After YAC_FDEF_POINTS"

    ! ! Set mask for cell centers
    ! CALL yac_fset_mask(cell_sea_land_mask >= 0, cell_point_id)
    

    attr_grid_total = ''
    do k = 1, nvar
       name = ''
       status = nf90_inquire_variable(ncid, k, name, xtype, ndims, dimids, natts)
       if (status /= nf90_noerr) then
          write(*, *) "OCN: n90_inquire_variable error"
          write(*, *) status
          stop
       endif

       write(*, *) "OCN: Results of nf90_inquire_variable call: ", ncid, ", ", k, ", ", trim(name), ", ", xtype, ", "
       write(*, *) "OCN: Results of nf90_inquire_variable call: ", ndims, ", ", dimids, ", ", natts

       if(xtype == NF90_DOUBLE) THEN
          if(ndims == 1) then
             write(*, *) "OCN: Type DOUBLE 1d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             allocate(field_double_1d(list_dimension_attr(dimids(1))%len_of_dim))
             write(*, *) "After allocation of field_double_1d"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_double_1d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             ! Output of field
             write(*, *) "OCN: field_double_1d"
             write(*, *) field_double_1d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             write(*, *) "OCN Before yac_fdef_field"
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field"
          endif

          if(ndims == 2) then
             write(*, *) "OCN: Type FLOAT 2d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(2))%len_of_dim
             allocate(field_double_2d(list_dimension_attr(dimids(1))%len_of_dim, list_dimension_attr(dimids(2))%len_of_dim))
             write(*, *) "After allocation of field_double_2d"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_double_2d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) "OCN: field_double_2d"
             write(*, *) field_double_2d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field"
          endif

          if(ndims == 3) then
             write(*, *) "OCN: Type DOUBLE 3d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(2))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(3))%len_of_dim
             allocate(field_double_3d(list_dimension_attr(dimids(1))%len_of_dim,&
                  list_dimension_attr(dimids(2))%len_of_dim, &
                  list_dimension_attr(dimids(3))%len_of_dim))
             write(*, *) "After allocation of field_double_4d"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_double_3d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) "OCN: field_double_4d"
             write(*, *) field_double_3d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field"

          endif

          
          if(ndims == 4) then
             write(*, *) "OCN: Type DOUBLE 4d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(2))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(3))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(4))%len_of_dim
             allocate(field_double_4d(list_dimension_attr(dimids(1))%len_of_dim,&
                  list_dimension_attr(dimids(2))%len_of_dim, &
                  list_dimension_attr(dimids(3))%len_of_dim, &
                  list_dimension_attr(dimids(4))%len_of_dim))
             write(*, *) "After allocation of field_double_4d"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_double_4d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) "OCN: field_double_4d"
             write(*, *) field_double_4d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field"

          endif

          ! Define fields metadata
          write(*, *) "OCN: Before yac_fdef_field_metadata"
          write(field_metadata, *) trim(name)
          call yac_fdef_field_metadata(comp_name, grid_name, name, field_metadata)
          write(*, *) "OCN: After yac_fdef_field_metadata"

       end if
       
       if(xtype == NF90_FLOAT) THEN
          if(ndims == 1) then
             write(*, *) "OCN: Type FLOAT 1d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             allocate(field_float_1d(list_dimension_attr(dimids(1))%len_of_dim))
             write(*, *) "After allocation"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_float_1d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) "OCN: field_float_1d"
             write(*, *) field_float_1d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field dim = 1"

             deallocate(field_float_1d)

          endif

          if(ndims == 2) then
             write(*, *) "OCN: Type FLOAT 2d"
             write(*, *) "OCN: dimids(1), dimids(2): ", dimids(1), dimids(2)
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(2))%len_of_dim
             allocate(field_float_2d(list_dimension_attr(dimids(1))%len_of_dim, list_dimension_attr(dimids(2))%len_of_dim))
             write(*, *) "After allocation"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_float_2d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) field_float_2d
             write(*, *)
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field dim = 2"
          endif


          if(ndims == 3) then
             write(*, *) "OCN: Type FLOAT 3d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(2))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(3))%len_of_dim
             allocate(field_float_3d(list_dimension_attr(dimids(1))%len_of_dim,&
                  list_dimension_attr(dimids(2))%len_of_dim, &
                  list_dimension_attr(dimids(3))%len_of_dim))
             write(*, *) "After allocation"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_float_3d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) field_float_3d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field dim =3"
          endif


          if(ndims == 4) then
             write(*, *) "OCN: Type FLOAT 4d"
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(1))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(2))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(3))%len_of_dim
             write(*, *) "OCN: list_dimension_attr%len_of_dim: ", list_dimension_attr(dimids(4))%len_of_dim
             allocate(field_float_4d(list_dimension_attr(dimids(1))%len_of_dim,&
                  list_dimension_attr(dimids(2))%len_of_dim, &
                  list_dimension_attr(dimids(3))%len_of_dim, &
                  list_dimension_attr(dimids(4))%len_of_dim))
             write(*, *) "After allocation"
             
             ! Get values fron variable
             write(*, *) "OCN: Before nf90_get_var"
             status = nf90_get_var( ncid, k, field_float_4d ) 
             if (status /= nf90_noerr) then
                write(*, *) "***** OCN: n90_get_var error *****"
                write(*, *) "OCN: status nf90_get_var: ", status
                stop 
             endif

             write(*, *) field_float_4d
             write(*, *) "OCN: After nf90_get_var"

             ! Define field
             CALL yac_fdef_field ( &
                  name, comp_id, point_ids, num_point_ids, collection_size, &
                  timestep, timestep_unit, def_field)
             write(*, *) "After yac_fdef_field dim = 4"
             ! Get field
 !            CALL yac_fget(k, num_points, 1, field, info, ierror)

             ! Get field name from field id
!             field_name = yac_fget_field_name(field_id)

!             IF (info /= YAC_ACTION_NONE) THEN
 !               ! Print some debugging output
  !              DO i = 1, collection_size
   !                WRITE(*, debug_format) &
    !                    comp_name, field_name, i, MINVAL(field(:,i)), MAXVAL(field(:,i))
     !           END DO
      !       END IF

             deallocate(field_float_4d)

          endif

          ! Define fields metadata
          write(*, *) "OCN: Before yac_fdef_field_metadata"
          write(field_metadata, *) trim(name)
          call yac_fdef_field_metadata(comp_name, grid_name, name, field_metadata)
          write(*, *) "OCN: After yac_fdef_field_metadata"

       end if

       
       if(index(trim(name), 'lon') /= 0) then
          
          status = nf90_get_var( ncid, k, x_cells ) !(/ 1,1,1 /) )
          if (status /= nf90_noerr) then
             write(*, *) "***** OCN: n90_get_var error *****"
             write(*, *) "OCN: status nf90_get_var: ", status
             stop 
          endif

          ! Correction
          ! Assumption:
          !    - whole erath (360 degrees laongitude, 180 degrees latitude)
          !    - cell centered and corner centered coordinates
          correction_value_lon = 360.0 / ((num_vertices_lon - 1) * 2)
          write(*, *) "OCN: correction_value_lon: ", correction_value_lon
          if( abs( x_cells(1) - (-180.0) ) > 1e-10) then
             write(*, *) "OCN: Cell centered values"
             do i = 1, num_vertices_lon - 1
                x_vertices(i) = x_cells(i) - correction_value_lon  ! 0.5
             end do
          else
             write(*, *) "OCN: Corner Centered values"
          end if
          x_vertices(num_vertices_lon) = 180.0
          write(*, *) x_vertices
          
          if(natts > 0) then
             write(* ,*) '==== OCN: data attributes (local) ===='
             call parse_attr_list(ncid, natts, k, attr_grid_total)
             write(*, *)
             write(*, *) "OCN: attr_grid_total (lon; from call): ", trim(attr_grid_total)
             write(*, *)
          endif

          cycle
       end if

       if(index(trim(name), 'lat') /= 0) then
!          allocate(y_vertices(num_vertices_lat))

          status = nf90_get_var( ncid, k, y_cells ) 
          if (status /= nf90_noerr) then
             write(*, *) "***** OCN: n90_get_var error *****"
             write(*, *) "OCN: status nf90_get_var: ", status
             stop 
          endif

          ! Corection
          ! Assumption:
          !    - whole erath (360 degrees laongitude, 180 degrees latitude)
          !    - cell and corner centered coordinates
          correction_value_lat = 180.0 / ((num_vertices_lat - 1) * 2)
          write(*, *) "OCN: correction_value_lat: ", correction_value_lat
          if( (y_cells(1) - (-90.0)) > 1e-10) then
             write(*, *) "OCN: Cell centered values"
             do i = 1, num_vertices_lat - 1
                y_vertices(i) = y_cells(i) - correction_value_lat  !0.5
             end do
          else
             write(*, *) "OCN: Cell centered values"
          end if
          y_vertices(num_vertices_lat) = 90.0

          if(natts > 0) then
             write(* ,*) '==== OCN: data attributes (local) ===='
             call parse_attr_list(ncid, natts, k, attr_grid_total)
             write(*, *)
             write(*, *) "OCN: attr_grid_total (lat; from call): ", trim(attr_grid_total)
             write(*, *)
          endif
          cycle
       end if

    enddo

    ! Output of the attributes
    if(natt > 0) then
       write(*, *) '==== OCN: global attributes ===='
       call parse_attr_list(ncid, natt, nf90_global, attr_grid_total)
       write(*, *)
       write(*, *) "OCN: attr_grid_total (global; from call): ", trim(attr_grid_total)
       write(*, *)
    endif

    !
    ! End of reading netCDF file
    !


    ! Define fields
    CALL define_fields( &
         comp_id, cell_point_id, field_taux_id, field_tauy_id, field_sfwflx_id, &
         field_sftemp_id, field_thflx_id, field_iceatm_id, field_sst_id, &
         field_oceanu_id, field_oceanv_id, field_iceoce_id)

    ! Complete definitions and compute interpolations
    CALL yac_fenddef()

    ! Initialise fields
    CALL init_fields()

    ! Execute model time loop
    DO t = 1, nsteps

       ! Simulate ocn timestep
       CALL sim_ocn_timestep(t)

       ! Exchange data with atm component
       CALL couple_to_atm()

    END DO ! time loop

  END SUBROUTINE main_ocn

  SUBROUTINE init_fields()

    INTEGER :: i

    ! Allocate output field buffers
    ALLOCATE( &
      sst(num_vertices, 1), oceanu(num_vertices, 1), oceanv(num_vertices, 1), &
      iceoce(num_vertices, 5))

    ! Initialise output field buffer with dummy data
!    DO i = 1, num_cells
!      sst(i,1) = yac_test_gulfstream_c(x_cells(i), y_cells(i))
!    END DO
    sst(:, 1) = 0.0d0
    oceanu(:,1) = 120.0d0
    oceanv(:,1) = 130.0d0
    iceoce(:,1) = 140.1d0
    iceoce(:,2) = 140.2d0
    iceoce(:,3) = 140.3d0
    iceoce(:,4) = 140.4d0
    iceoce(:,5) = 140.5d0

    ! Allocate input field buffers
    ALLOCATE( &
      taux(num_vertices, 2), tauy(num_vertices, 2), sfwflx(num_vertices, 3), &
      sftemp(num_vertices, 1), thflx(num_vertices, 4), iceatm(num_vertices, 4))

    ! Initialise input field buffer with zero
    taux(:,1) = 0.0d0
    taux(:,2) = 0.0d0
    tauy(:,1) = 0.0d0
    tauy(:,2) = 0.0d0
    sfwflx(:,1) = 0.0d0
    sfwflx(:,2) = 0.0d0
    sfwflx(:,3) = 0.0d0
    sftemp(:,1) = 0.0d0
    thflx(:,1) = 0.0d0
    thflx(:,2) = 0.0d0
    thflx(:,3) = 0.0d0
    thflx(:,4) = 0.0d0
    iceatm(:,1) = 0.0d0
    iceatm(:,2) = 0.0d0
    iceatm(:,3) = 0.0d0
    iceatm(:,4) = 0.0d0

  END SUBROUTINE init_fields

  SUBROUTINE sim_ocn_timestep(timestep)

    INTEGER, INTENT(IN) :: timestep

    ! Do an ocean timestep

    ! ...

    CALL MPI_Barrier(comp_comm, ierror)
    IF (comp_rank == 0) &
      PRINT "('--- ',A3,' timestep ',I2,' ---')", comp_name, timestep

  END SUBROUTINE sim_ocn_timestep

  SUBROUTINE couple_to_atm()

    ! --------------------
    ! Send fields to ocean
    ! --------------------

    ! Send sea surface temperature
    CALL send_field(field_sst_id, sst)

    ! Send zonal velocity
    CALL send_field(field_oceanu_id, oceanu)

    ! Send meridional velocity
    CALL send_field(field_oceanv_id, oceanv)

    ! Send Ice thickness, concentration, T1 and T2
    CALL send_field(field_iceoce_id, iceoce)

    ! -------------------------
    ! Receive fields from ocean
    ! -------------------------

    ! Recieve meridional wind stress
    CALL receive_field(comp_name, field_taux_id, taux)

    ! Recieve zonal  wind stress
    CALL receive_field(comp_name, field_tauy_id, tauy)

    ! Recieve surface fresh water flux
    CALL receive_field(comp_name, field_sfwflx_id, sfwflx)

    ! Recieve surface temperature
    CALL receive_field(comp_name, field_sftemp_id, sftemp)

    ! Recieve total heat flux
    CALL receive_field(comp_name, field_thflx_id, thflx)

    ! Recieve ice temperatures and melt potential
    CALL receive_field(comp_name, field_iceatm_id, iceatm)

  END SUBROUTINE couple_to_atm



  !=============================================================================
  subroutine parse_attr_list( ncid, n_attr_loc, varid, attr_grid_total )
    use netcdf

    character(len = 1024) :: c1d, name
    character(len = 4096) :: attr_grid_total

    integer(kind = 4) :: ncid, n_attr_loc, varid
    integer(kind = 4) :: xtype, len, status
    integer(kind = 4) :: k, kk

    real(kind = 8) :: rval

    integer(kind = 4), allocatable, dimension(:) :: ivals
    real(kind = 8), allocatable, dimension(:) :: rvals

    do k = 1, n_attr_loc
       status = nf90_inq_attname(ncid, varid, k, name)
       status = nf90_inquire_attribute(ncid, varid, name, xtype, len, kk)

       if (xtype == NF90_CHAR) then
          if (len > 1024) then
             write(*,*) 'truncating attribute to length:', 1024
          endif
          status = nf90_get_att(ncid, varid, name, c1d )
          if (status /= 0) stop 'error calling get_att'
          name = trim(name)
          attr_grid_total = trim(attr_grid_total)

          !write(attr_grid_total, '(A, "; ", A, " ", A)') trim(attr_grid_total), trim(name), trim(c1d)
          !write(*, *) "OCN attrgrid_total (in subroutine): ", trim(attr_grid_total) 
       else if ( xtype == NF90_INT ) then
          write(*, *) "OCN: Attribute type is NF90_INT"
          if (len > 1) then
             allocate( ivals(len) )
             status = nf90_get_att(ncid, varid, name, ivals )
             if (status /= 0) stop "error calling get_att for integer array"
             deallocate( ivals )
          else
             status = nf90_get_att(ncid, varid, name, ivals )
             if (status /= 0) stop 'error calling get_att for integer'
          endif
          write(*, *) "OCN: xtype_attr NF90_INT: ", xtype
       else if( xtype == NF90_FLOAT ) then
          write(*, *) "OCN: Attribute type is NF90_FLOAT"
          if (len > 1) then
             allocate( rvals(len) )
             status = nf90_get_att(ncid, varid, name, rvals )
             if (status /= 0) stop 'error calling get_att for real array'
             deallocate( rvals )
          else
             status = nf90_get_att(ncid, varid, name, rval )
             if(status /= 0) stop "error calling get_att for real"
          endif
       else if( xtype == NF90_DOUBLE ) then
          write(*, *) "OCN: Attribute type is NF90_DOUBLE"
          if (len > 1) then
             allocate( rvals(len) )
             status = nf90_get_att(ncid, varid, name, rvals )
             if (status /= 0) stop "error calling get_att for real array"
             deallocate( rvals )
          else
             status = nf90_get_att(ncid, varid, name, rval )
             if(status /= 0) stop "error calling get_att for real"
          endif
       endif
    enddo
  end subroutine parse_attr_list
END MODULE toy_ocn

PROGRAM main_ocn_program
  USE mpi
  USE yac
  USE toy_ocn, ONLY : main_ocn

  IMPLICIT NONE

  INTEGER :: ierror

  ! Initialise MPI
  CALL MPI_Init(ierror)

  ! Initialise the YAC
  CALL yac_finit()

  ! Run atmosphere model
  CALL main_ocn(MPI_COMM_WORLD)

  ! Finalise YAC
  CALL yac_ffinalize()

  ! Finalise MPI
  CALL MPI_Finalize(ierror)
END PROGRAM main_ocn_program
